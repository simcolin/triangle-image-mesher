<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triangle Image Mesher</title>
    <meta name="description" content="Just a website to make your image more ... triangular">
    <style>
        html {
            height: 100%;
        }

        body {
            margin: 0;
            background: #333;
            color: #fff;
            font-family: Arial, Helvetica, sans-serif;
            display: flex;
            height: 100%;
            overflow: hidden;
        }

        * {
            box-sizing: border-box;
        }

        nav {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-shrink: 0;
            flex-basis: content;
            padding: 1rem;
        }

        label {
            margin-bottom: 0.2rem;
        }

        input {
            background: none;
            border: 2px solid #fff;
            color: inherit;
            padding: 0.5rem 1rem;
            appearance: none;
            outline: none;
            width: 100%;
        }

        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type=number] {
            -moz-appearance: textfield;
        }

        .dropzone {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #fff;
            height: 10rem;
            cursor: pointer;
            user-select: none;
        }

        .dropzone:hover {
            background: #fff1;
        }

        a {
            margin-top: auto;
            color: inherit;
        }

        .mb-1rem {
            margin-bottom: 1rem;
        }

        button {
            outline: none;
            padding: 0.5rem 1rem;
            border: 2px solid #fff;
            background: #fff;
            color: #222;
            cursor: pointer;
            width: 100%;
        }

        button:hover {
            background: transparent;
            color: #fff;
        }

        button.disabled {
            border-color: #aaa;
            background: #aaa;
            cursor: no-drop;
        }

        .canvas-ctn {
            flex-grow: 1;
            flex-basis: auto;
            background: #222;
        }

        canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <nav>
        <h2>Triangle Image Mesher</h2>
        <p>
            Drop an image, see the result,<br>
            Play with values and press generate,<br>
            Download the result if you like it
        </p>
        <label for="randomness-input">Image</label>
        <input class="hidden" type="file" accept="image/*" id="image-input">
        <div class="dropzone mb-1rem">Drag & drop or click here</div>
        <label for="spacing-input">Spacing</label>
        <input type="number" min="1" id="spacing-input" class="mb-1rem">
        <label for="randomness-input">Randomness</label>
        <input type="number" min="0" id="randomness-input" class="mb-1rem">
        <button id="generate-button" class="mb-1rem">Generate</button>
        <button id="download-button" class="disabled mb-1rem">Download Result</button>
        <a href="https://github.com/simcolin/triangle-image-mesher" target="blank">Github</a>
    </nav>
    <div class="canvas-ctn">
        <canvas id="canvas"></canvas>
    </div>
    <script>
        /** @type {HTMLInputElement} */
        const input = document.getElementById("image-input");
        /** @type {HTMLDivElement} */
        const dropzone = document.querySelector(".dropzone");
        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById("canvas");
        /** @type {HTMLInputElement} */
        const spacingInput = document.getElementById("spacing-input");
        /** @type {HTMLInputElement} */
        const randomnessInput = document.getElementById("randomness-input");
        /** @type {HTMLButtonElement} */
        const generateButton = document.getElementById("generate-button");
        /** @type {HTMLButtonElement} */
        const downloadButton = document.getElementById("download-button");
        const ctx = canvas.getContext("2d");

        let spacing = 20;
        let randomness = 10;
        /** @type {Blob} */
        let blob;

        spacingInput.value = spacing;
        randomnessInput.value = randomness;

        spacingInput.onchange = () => {
            spacing = spacingInput.value;
        }

        randomnessInput.onchange = () => {
            randomness = randomnessInput.value;
        }

        generateButton.onclick = tryReadFile;
        downloadButton.onclick = downloadCanvas;

        dropzone.onclick = () => input.click();
        dropzone.ondragover = (event) => {
            event.preventDefault();
        }
        dropzone.ondrop = (event) => {
            event.preventDefault();
            event.stopPropagation();
            file = event.dataTransfer.items[0]?.getAsFile();
            tryReadFile();
        }

        /** @type {File} */
        let file;

        input.onchange = (e) => {
            file = e.target.files[0];
            tryReadFile();
        }

        function downloadCanvas() {
            if(!blob) return;
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.download = "convert.png";
            link.href = url;
            link.click();
            link.remove();
        }

        /**
         * @param {File} file 
         */
        function tryReadFile() {
            if(!file) return;
            dropzone.textContent = `${file.name} (${toReadableSize(file.size)})`;
            const reader = new FileReader();
            reader.onload = () => {
                const image = new Image();
                image.onload = () => {
                    drawImageToCanvas(image);
                }
                spacingInput.max = Math.min(image.naturalWidth, image.naturalHeight);
                randomnessInput.max = spacingInput.max;
                image.src = reader.result;
            }

            reader.readAsDataURL(file);
        }

        /**
         * @param {HTMLImageElement} image 
         */
        function drawImageToCanvas(image) {
            ctx.canvas.width = image.naturalWidth;
            ctx.canvas.height = image.naturalHeight;
            ctx.drawImage(image, 0, 0);

            generateRandomPoints(image.naturalWidth, image.naturalHeight);
        }

        /**
         * @param {number} width 
         * @param {number} height 
         */
        async function generateRandomPoints(width, height) {
            const xCount = Math.ceil(width / spacing);
            const yCount = Math.ceil(height / spacing);

            const points = [];
            const colors = [];
            for(let x = 0; x < xCount; ++x) {
                points[x] = [];
                colors[x] = [];
                for(let y = 0; y < yCount; ++y) {
                    const point = {
                        x: Math.floor((x * spacing) + (Math.random() - 0.5) * randomness),
                        y: Math.floor((y * spacing) + (Math.random() - 0.5) * randomness),
                    };
                    points[x][y] = point;
                    
                    const pixel = ctx.getImageData(point.x, point.y, 1, 1).data;
                    colors[x][y] = `#${byteToHex(pixel[0])}${byteToHex(pixel[1])}${byteToHex(pixel[2])}`;
                }
            }
            
            drawTriangles(points, colors, xCount, yCount);
        }

        /**

        * @param {{x:number, y:number}} a 
        * @param {{x:number, y:number}} b 
        * @param {{x:number, y:number}} c 
        * @param {string} ac 
        * @param {string} bc 
        * @param {string} cc 
        */
        function drawTriangleGradient(a, b, c, ac, bc, cc) {
            const radius = 50;
            const grd1 = ctx.createRadialGradient(a.x, a.y, 0, a.x, a.y, radius);
            grd1.addColorStop(0, ac + "ff");
            grd1.addColorStop(1, ac + "00");

            const grd2 = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, radius);
            grd2.addColorStop(0, bc + "ff");
            grd2.addColorStop(1, bc + "00");

            const grd3 = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, radius);
            grd3.addColorStop(0, cc + "ff");
            grd3.addColorStop(1, cc + "00");

            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.lineTo(c.x, c.y);
            ctx.closePath();

            ctx.fillStyle = "#000";
            ctx.fill();

            ctx.globalCompositeOperation = "lighter";
            ctx.fillStyle = grd1;
            ctx.fill();
            ctx.fillStyle = grd2;
            ctx.fill();
            ctx.fillStyle = grd3;
            ctx.fill();
            ctx.globalCompositeOperation = "source-over";
        }

        /**
         * @param {{x: number, y: number}[][]} points 
         * @param {string[][]} colors 
         * @param {number} xCount 
         * @param {number} yCount 
         */
        function drawTriangles(points, colors, xCount, yCount) {
            for(let x = 0; x < xCount - 1; ++x) {
                for(let y = 0; y < yCount - 1; ++y) {
                    const a = points[x][y];
                    const b = points[x + 1][y];
                    const c = points[x][y + 1];
                    const d = points[x + 1][y + 1];

                    const ac = colors[x][y];
                    const bc = colors[x + 1][y];
                    const cc = colors[x][y + 1];
                    const dc = colors[x + 1][y + 1];

                    if(Math.random() > 0.5) {
                        drawTriangleGradient(a, b, c, ac, bc, cc);
                        drawTriangleGradient(b, c, d, bc, cc, dc);
                    } else {
                        drawTriangleGradient(a, b, d, ac, bc, dc);
                        drawTriangleGradient(a, c, d, ac, cc, dc);
                    }
                }
            }
            
            canvas.toBlob(b => {
                if(b) {
                    blob = b;
                    downloadButton.classList.remove("disabled");
                    downloadButton.textContent = `Download Result (${toReadableSize(blob.size)})`;
                }
            });
        }

        /**
         * @param {number} byte
         */
        function byteToHex(byte) {
            return byte.toString(16).padStart(2, "0");
        }

        /**
         * @param {number} size
         */
        function toReadableSize(size) {
            if(size < 1024) return size.toFixed(1) + ' B';
            size /= 1024;
            if(size < 1024) return size.toFixed(1) + ' kB';
            size /= 1024;
            if(size < 1024) return size.toFixed(1) + ' MB';
            size /= 1024;
            return size.toFixed(1) + ' GB';
        }
    </script>
</body>
</html>